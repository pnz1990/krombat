# Kubernetes RPG

An interactive, turn-based dungeon game where the entire game state lives in Kubernetes — orchestrated by [kro](https://kro.run) ResourceGraphDefinitions running as an [EKS Managed Capability](https://docs.aws.amazon.com/eks/latest/userguide/kro.html). No custom controllers, no external databases. Just declarative resource graphs, CEL expressions, and the Kubernetes control plane acting as a programmable state machine.

## Concept

Kubernetes RPG reframes Kubernetes from "container scheduler" to "general-purpose orchestration engine" by modeling RPG game mechanics entirely as Kubernetes resources:

| Game Entity | Kubernetes Resource |
|-------------|-------------------|
| Dungeon     | Custom Resource (generated by kro RGD) |
| Monster     | Pod |
| Boss        | Pod (with readiness gating) |
| Attack      | Custom Resource → Job |
| Treasure    | Secret |

Each dungeon instance gets its own Namespace for isolation and clean teardown.

## How It Works

1. **Create a Dungeon** — specify monster count and difficulty (easy/normal/hard)
2. **kro reconciles** — creates a namespace, monster pods, and a pending boss
3. **Attack monsters** — submit Attack CRs that spawn Jobs to atomically decrement HP via annotation patches
4. **Boss unlocks** — when all monsters are dead, the boss transitions to "ready"
5. **Defeat the boss** — a Treasure Secret is conditionally created on victory

All state transitions are driven by kro's reconciliation loop. The system is intentionally turn-based with 1–3 second latency tolerance, matching Kubernetes' performance envelope.

## Architecture

```
┌─────────────┐     ┌─────────────┐     ┌──────────────────────┐
│  React SPA  │────▶│  Go Backend │────▶│  Kubernetes API       │
│  (stateless)│◀────│  (gateway)  │◀────│  + kro controller     │
└─────────────┘  WS └─────────────┘watch└──────────────────────┘
```

- **Frontend** — React SPA rendering dungeon state with real-time WebSocket updates
- **Backend** — Stateless Go service that validates requests, proxies K8s operations, and streams events
- **Kubernetes + kro** — Sole source of truth. kro runs as an [EKS Managed Capability](https://docs.aws.amazon.com/eks/latest/userguide/kro.html). RGDs define resource graphs with dependency resolution, dynamic pod generation, readiness gating, and conditional resource creation

## Key Demonstrations

- **Dynamic resource generation** — Monster pod count driven by CEL expressions in the RGD
- **Cross-resource state derivation** — Boss readiness depends on aggregated monster state
- **Conditional resource creation** — Treasure only materializes after boss defeat
- **Drift correction** — Delete an alive monster pod and kro recreates it; delete a dead one and it stays gone
- **Optimistic concurrency** — Attack Jobs use resourceVersion preconditions for safe concurrent metadata mutation

## Prerequisites

- Amazon EKS cluster with the [kro managed capability](https://docs.aws.amazon.com/eks/latest/userguide/kro.html) enabled
- `kubectl` configured for the target cluster

## Access

The frontend and backend are not publicly exposed. Access is provided via `kubectl port-forward`:

```bash
# Backend API
kubectl port-forward svc/rpg-backend 8080:8080

# Frontend
kubectl port-forward svc/rpg-frontend 3000:3000
```

## License

MIT
