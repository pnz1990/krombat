# Kubernetes RPG

An interactive, turn-based dungeon game where the entire game state lives in Kubernetes — orchestrated by [kro](https://kro.run) ResourceGraphDefinitions running as an [EKS Managed Capability](https://docs.aws.amazon.com/eks/latest/userguide/kro.html). No custom controllers, no external databases. Just declarative resource graphs, CEL expressions, and the Kubernetes control plane acting as a programmable state machine.

## Concept

Kubernetes RPG reframes Kubernetes from "container scheduler" to "general-purpose orchestration engine" by modeling RPG game mechanics entirely as Kubernetes resources:

| Game Entity | Kubernetes Resource |
|-------------|-------------------|
| Dungeon     | Custom Resource (generated by kro RGD) |
| Monster     | Pod (labels/annotations derived from Dungeon CR) |
| Boss        | Pod (state derived from monster HP values) |
| Attack      | Custom Resource → Job (patches Dungeon CR) |
| Treasure    | Secret |

Each dungeon instance gets its own Namespace for isolation and clean teardown.

## How It Works

1. **Create a Dungeon** — specify monster count and difficulty (easy/normal/hard)
2. **kro reconciles** — creates a namespace, monster pods (with HP from difficulty), a pending boss, and a treasure Secret
3. **Attack monsters** — submit Attack CRs; kro's attack-graph RGD spawns a Job that patches the Dungeon CR's `monsterHP` array
4. **kro re-reconciles** — derives pod labels from HP values: monsters with HP=0 become `state=dead`
5. **Boss unlocks** — when all monster HP=0, kro transitions the boss to `state=ready`
6. **Defeat the boss** — attack the boss to reduce `bossHP` to 0; kro sets `state=defeated` and victory=true

All state transitions are driven by kro's reconciliation loop. The system is intentionally turn-based with 1–3 second latency tolerance, matching Kubernetes' performance envelope.

## Architecture

```
┌─────────────┐     ┌─────────────┐     ┌──────────────────────┐
│  React SPA  │────▶│  Go Backend │────▶│  Kubernetes API       │
│  (stateless)│◀────│  (gateway)  │◀────│  + kro controller     │
└─────────────┘  WS └─────────────┘watch└──────────────────────┘
                                              ▲
                                              │ sync
                                         ┌────┴─────┐
                                         │ Argo CD  │
                                         │ (GitOps) │
                                         └────┬─────┘
                                              │
                                         ┌────┴─────┐
                                         │ Git Repo │
                                         └──────────┘
```

- **Frontend** — React SPA rendering dungeon state with real-time WebSocket updates (TODO)
- **Backend** — Stateless Go service with REST API + WebSocket. Validates requests, proxies K8s operations, streams events. Includes rate limiting (1 attack/s per dungeon) and Prometheus metrics on `/metrics`
- **Kubernetes + kro** — Sole source of truth. kro runs as an [EKS Managed Capability](https://docs.aws.amazon.com/eks/latest/userguide/kro.html). Two RGDs orchestrate the game: `dungeon-graph` (state management) and `attack-graph` (combat)
- **Argo CD** — Runs as an [EKS Managed Capability](https://docs.aws.amazon.com/eks/latest/userguide/argocd.html). Continuously syncs all cluster manifests from this Git repo. GitHub webhook configured for ~6s sync latency

## Key Demonstrations

- **Two-RGD orchestration** — `dungeon-graph` manages game state, `attack-graph` handles combat; both coordinated by kro
- **Dynamic resource generation** — Monster pod count driven by CEL expressions in the RGD
- **Cross-resource state derivation** — Boss readiness depends on aggregated monster HP values via CEL
- **Drift correction** — Delete an alive monster pod and kro recreates it with correct state from Dungeon CR
- **Optimistic concurrency** — Attack Jobs use resourceVersion preconditions for safe concurrent Dungeon CR mutation

## Project Structure

```
├── backend/                 # Go backend service
│   ├── cmd/                 # Entrypoint
│   ├── internal/            # Handlers, K8s client, WebSocket hub
│   └── Dockerfile           # Multi-stage build (distroless)
├── manifests/               # Argo CD syncs this directory
│   ├── apps/                # Argo CD Application
│   ├── rbac/                # ServiceAccounts, Roles, Bindings
│   ├── rgds/                # kro ResourceGraphDefinitions
│   └── system/              # Backend deployment, dungeon reaper
├── infra/                   # Terraform (EKS, capabilities, ECR, CI)
├── tests/                   # Integration test suites
│   ├── run.sh               # Game engine tests (27 tests)
│   └── backend-api.sh       # Backend API tests (14 tests)
├── docs/                    # Design documents and runbook
└── .github/workflows/       # CI pipelines
```

## Prerequisites

- Amazon EKS cluster with the [kro](https://docs.aws.amazon.com/eks/latest/userguide/kro.html) and [Argo CD](https://docs.aws.amazon.com/eks/latest/userguide/argocd.html) managed capabilities enabled
- `kubectl` configured for the target cluster
- See [infra/SETUP.md](infra/SETUP.md) for full provisioning guide

## Access

The backend is not publicly exposed. Access via `kubectl port-forward`:

```bash
kubectl port-forward svc/rpg-backend -n rpg-system 8080:8080
```

## Quick Start (kubectl only, no UI needed)

```bash
# Create a dungeon
cat <<EOF | kubectl apply -f -
apiVersion: game.k8s.example/v1alpha1
kind: Dungeon
metadata:
  name: my-dungeon
spec:
  monsters: 3
  difficulty: normal
  monsterHP: [50, 50, 50]
  bossHP: 400
EOF

# Wait for kro to reconcile (~10s), then check state
kubectl get pods -n my-dungeon -o custom-columns='NAME:.metadata.name,HP:.metadata.annotations.game\.k8s\.example/hp,STATE:.metadata.labels.game\.k8s\.example/state'

# Attack a monster
cat <<EOF | kubectl apply -f -
apiVersion: game.k8s.example/v1alpha1
kind: Attack
metadata:
  name: attack-1
spec:
  dungeonName: my-dungeon
  dungeonNamespace: default
  target: my-dungeon-monster-0
  damage: 50
EOF

# Check dungeon status
kubectl get dungeon my-dungeon -o jsonpath='{.status}'
```

## License

MIT
