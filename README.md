# Kubernetes RPG

An interactive, turn-based dungeon game where the entire game state lives in Kubernetes — orchestrated by [kro](https://kro.run) ResourceGraphDefinitions running as an [EKS Managed Capability](https://docs.aws.amazon.com/eks/latest/userguide/kro.html). No custom controllers, no external databases. Just declarative resource graphs, CEL expressions, and the Kubernetes control plane acting as a programmable state machine.

## Concept

Kubernetes RPG reframes Kubernetes from "container scheduler" to "general-purpose orchestration engine" by modeling RPG game mechanics entirely as Kubernetes resources:

| Game Entity | Kubernetes Resource |
|-------------|-------------------|
| Dungeon     | Custom Resource (generated by kro RGD) |
| Monster     | Pod |
| Boss        | Pod (with readiness gating) |
| Attack      | Custom Resource → Job |
| Treasure    | Secret |

Each dungeon instance gets its own Namespace for isolation and clean teardown.

## How It Works

1. **Create a Dungeon** — specify monster count and difficulty (easy/normal/hard)
2. **kro reconciles** — creates a namespace, monster pods (with HP from difficulty), a pending boss, and a treasure Secret
3. **Attack monsters** — submit Attack CRs; kro's attack-graph RGD spawns a Job that patches the Dungeon CR's `monsterHP` array
4. **kro re-reconciles** — derives pod labels from HP values: monsters with HP=0 become `state=dead`
5. **Boss unlocks** — when all monster HP=0, kro transitions the boss to `state=ready`
6. **Defeat the boss** — attack the boss to reduce `bossHP` to 0; kro sets `state=defeated` and victory=true

All state transitions are driven by kro's reconciliation loop. The system is intentionally turn-based with 1–3 second latency tolerance, matching Kubernetes' performance envelope.

## Architecture

```
┌─────────────┐     ┌─────────────┐     ┌──────────────────────┐
│  React SPA  │────▶│  Go Backend │────▶│  Kubernetes API       │
│  (stateless)│◀────│  (gateway)  │◀────│  + kro controller     │
└─────────────┘  WS └─────────────┘watch└──────────────────────┘
                                              ▲
                                              │ sync
                                         ┌────┴─────┐
                                         │ Argo CD  │
                                         │ (GitOps) │
                                         └────┬─────┘
                                              │
                                         ┌────┴─────┐
                                         │ Git Repo │
                                         └──────────┘
```

- **Frontend** — React SPA rendering dungeon state with real-time WebSocket updates
- **Backend** — Stateless Go service that validates requests, proxies K8s operations, and streams events
- **Kubernetes + kro** — Sole source of truth. kro runs as an [EKS Managed Capability](https://docs.aws.amazon.com/eks/latest/userguide/kro.html). RGDs define resource graphs with dependency resolution, dynamic pod generation, readiness gating, and conditional resource creation
- **Argo CD** — Runs as an [EKS Managed Capability](https://docs.aws.amazon.com/eks/latest/userguide/argocd.html). Continuously syncs all cluster manifests (CRDs, RGDs, RBAC, deployments, policies) from this Git repo

## Key Demonstrations

- **Two-RGD orchestration** — `dungeon-graph` manages game state, `attack-graph` handles combat; both coordinated by kro
- **Dynamic resource generation** — Monster pod count driven by CEL expressions in the RGD
- **Cross-resource state derivation** — Boss readiness depends on aggregated monster HP values
- **Conditional resource creation** — Treasure only materializes after boss defeat
- **Drift correction** — Delete an alive monster pod and kro recreates it; delete a dead one and it stays gone
- **Optimistic concurrency** — Attack Jobs use resourceVersion preconditions for safe concurrent Dungeon CR mutation

## Prerequisites

- Amazon EKS cluster with the [kro](https://docs.aws.amazon.com/eks/latest/userguide/kro.html) and [Argo CD](https://docs.aws.amazon.com/eks/latest/userguide/argocd.html) managed capabilities enabled
- `kubectl` configured for the target cluster

## Access

The frontend and backend are not publicly exposed. Access is provided via `kubectl port-forward`:

```bash
# Backend API
kubectl port-forward svc/rpg-backend 8080:8080

# Frontend
kubectl port-forward svc/rpg-frontend 3000:3000
```

## License

MIT
