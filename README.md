# Kubernetes RPG

An interactive, turn-based dungeon game where the entire game state lives in Kubernetes — orchestrated by [kro](https://kro.run) ResourceGraphDefinitions running as an [EKS Managed Capability](https://docs.aws.amazon.com/eks/latest/userguide/kro.html). No custom controllers, no external databases. Just declarative resource graphs, CEL expressions, and the Kubernetes control plane acting as a programmable state machine.

## Concept

Kubernetes RPG reframes Kubernetes from "container scheduler" to "general-purpose orchestration engine" by modeling RPG game mechanics entirely as Kubernetes resources:

| Game Entity | Kubernetes Resource |
|-------------|-------------------|
| Dungeon     | Custom Resource (generated by kro RGD) |
| Monster     | Pod (labels/annotations derived from Dungeon CR) |
| Boss        | Pod (state derived from monster HP values) |
| Attack      | Custom Resource → Job (patches Dungeon CR) |
| Treasure    | Secret (loot exposed via Dungeon CR status) |

Each dungeon instance gets its own Namespace for isolation and clean teardown.

## How It Works

1. **Create a Dungeon** — specify monster count and difficulty (easy/normal/hard)
2. **kro reconciles** — creates a namespace, monster pods (with HP from difficulty), a pending boss, and a treasure Secret
3. **Attack monsters** — submit Attack CRs; kro's attack-graph RGD spawns a Job that patches the Dungeon CR's `monsterHP` array
4. **kro re-reconciles** — derives pod labels from HP values: monsters with HP=0 become `state=dead`
5. **Boss unlocks** — when all monster HP=0, kro transitions the boss to `state=ready`
6. **Defeat the boss** — attack the boss to reduce `bossHP` to 0; kro sets `state=defeated` and victory=true

The backend and frontend only interact with kro-generated CRs (Dungeon and Attack). All game logic — HP calculations, state transitions, resource creation — lives in kro's CEL expressions and resource graph definitions.

## Architecture

```
┌─────────────┐     ┌─────────────┐     ┌──────────────────────┐
│  React SPA  │────▶│  Go Backend │────▶│  Kubernetes API       │
│  (8-bit UI) │◀────│  (gateway)  │◀────│  + kro controller     │
└─────────────┘  WS └─────────────┘watch└──────────────────────┘
     nginx              │                       ▲
     proxy ─────────────┘                       │ sync
                                           ┌────┴─────┐
                                           │ Argo CD  │
                                           │ (GitOps) │
                                           └────┬─────┘
                                                │
                                           ┌────┴─────┐
                                           │ Git Repo │
                                           └──────────┘
```

- **Frontend** — 8-bit D&D-inspired React SPA with pixel art styling. Nginx reverse-proxies `/api/` to the backend. All game state derived from the Dungeon CR
- **Backend** — Stateless Go service. Only touches Dungeon and Attack CRs — never reads Pods, Secrets, or Jobs. Includes rate limiting (1 attack/s per dungeon) and Prometheus metrics on `/metrics`
- **Kubernetes + kro** — Sole source of truth. Two RGDs orchestrate the game: `dungeon-graph` (state management) and `attack-graph` (combat). kro runs as an [EKS Managed Capability](https://docs.aws.amazon.com/eks/latest/userguide/kro.html)
- **Argo CD** — Runs as an [EKS Managed Capability](https://docs.aws.amazon.com/eks/latest/userguide/argocd.html). Continuously syncs all cluster manifests from this Git repo. GitHub webhook for ~6s sync latency

## Key Demonstrations

- **Two-RGD orchestration** — `dungeon-graph` manages game state, `attack-graph` handles combat
- **Dynamic resource generation** — Monster pod count driven by CEL expressions
- **Cross-resource state derivation** — Boss readiness depends on aggregated monster HP values via CEL
- **Drift correction** — Delete an alive monster pod and kro recreates it with correct state from Dungeon CR
- **Optimistic concurrency** — Attack Jobs use resourceVersion preconditions for safe concurrent Dungeon CR mutation
- **CRs as the only interface** — Backend never touches native K8s objects; kro is the abstraction layer

## Project Structure

```
├── backend/                 # Go backend service
│   ├── cmd/                 # Entrypoint
│   ├── internal/            # Handlers, K8s client, WebSocket hub
│   └── Dockerfile           # Multi-stage build (distroless)
├── frontend/                # React SPA
│   ├── src/                 # App, API client, WebSocket hook, CSS
│   ├── nginx.conf           # Reverse proxy to backend
│   └── Dockerfile           # Node build + nginx runtime
├── manifests/               # Argo CD syncs this directory
│   ├── apps/                # Argo CD Application
│   ├── rbac/                # ServiceAccounts, Roles, Bindings
│   ├── rgds/                # kro ResourceGraphDefinitions
│   └── system/              # Backend/frontend deployments, dungeon reaper
├── infra/                   # Terraform (EKS, capabilities, ECR, CI)
├── tests/                   # Integration test suites
│   ├── run.sh               # Game engine tests (27 tests)
│   └── backend-api.sh       # Backend API tests (14 tests)
├── scripts/                 # Utility scripts
│   └── watch-dungeon.sh     # tmux dashboard for watching game state
├── docs/                    # Design documents and runbook
└── .github/workflows/       # CI pipelines
```

## Prerequisites

- Amazon EKS cluster with the [kro](https://docs.aws.amazon.com/eks/latest/userguide/kro.html) and [Argo CD](https://docs.aws.amazon.com/eks/latest/userguide/argocd.html) managed capabilities enabled
- `kubectl` configured for the target cluster
- See [infra/SETUP.md](infra/SETUP.md) for full provisioning guide

## Running the Game

The backend and frontend run in the `rpg-system` namespace, deployed via Argo CD from the `manifests/` directory.

### Access the UI

```bash
kubectl port-forward svc/rpg-frontend -n rpg-system 3000:3000
```

Open http://localhost:3000 — create a dungeon, attack monsters, defeat the boss.

### Access the Backend API directly

```bash
kubectl port-forward svc/rpg-backend -n rpg-system 8080:8080
```

```bash
# Create a dungeon
curl -X POST http://localhost:8080/api/v1/dungeons \
  -H "Content-Type: application/json" \
  -d '{"name":"my-dungeon","monsters":3,"difficulty":"normal"}'

# List dungeons
curl http://localhost:8080/api/v1/dungeons

# Get dungeon state
curl http://localhost:8080/api/v1/dungeons/default/my-dungeon

# Attack a monster
curl -X POST http://localhost:8080/api/v1/dungeons/default/my-dungeon/attacks \
  -H "Content-Type: application/json" \
  -d '{"target":"my-dungeon-monster-0","damage":50}'
```

### Watch game state (tmux dashboard)

```bash
./scripts/watch-dungeon.sh my-dungeon
```

### Play via kubectl only (no UI needed)

```bash
# Create a dungeon
cat <<EOF | kubectl apply -f -
apiVersion: game.k8s.example/v1alpha1
kind: Dungeon
metadata:
  name: my-dungeon
spec:
  monsters: 3
  difficulty: normal
  monsterHP: [50, 50, 50]
  bossHP: 400
EOF

# Wait for kro (~10s), then check state
kubectl get dungeon my-dungeon -o jsonpath='{.status}'

# Attack a monster
cat <<EOF | kubectl apply -f -
apiVersion: game.k8s.example/v1alpha1
kind: Attack
metadata:
  name: attack-1
spec:
  dungeonName: my-dungeon
  dungeonNamespace: default
  target: my-dungeon-monster-0
  damage: 50
EOF

# Clean up
kubectl delete dungeon my-dungeon
```

## License

MIT
